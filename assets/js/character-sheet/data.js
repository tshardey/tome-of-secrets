// Import data from JSON files (source of truth)
// These exports are generated by: node scripts/generate-data.js
import { 
    expansions,
    xpLevels, 
    permanentBonuses, 
    atmosphericBuffs,
    schoolBenefits,
    sanctumBenefits,
    keeperBackgrounds,
    allItems,
    dungeonRooms,
    masteryAbilities,
    dungeonRewards,
    dungeonCompletionRewards,
    genreQuests,
    extraCreditRewards,
    sideQuestsDetailed,
    curseTableDetailed,
    temporaryBuffsFromRewards,
    temporaryBuffs,
    levelRewards,
    shoppingOptions,
    wings,
    restorationProjects,
    roomThemes
} from './data.json-exports.js';

// Derive allGenres from genreQuests (genre name -> description mapping)
// This consolidates genre data into a single source of truth
export const allGenres = (() => {
    const result = {};
    for (const key of Object.keys(genreQuests)) {
        const quest = genreQuests[key];
        result[quest.genre] = quest.description;
    }
    return result;
})();

// Re-export JSON data for backward compatibility
export { expansions, xpLevels, permanentBonuses, atmosphericBuffs, schoolBenefits, sanctumBenefits, keeperBackgrounds, allItems, dungeonRooms, masteryAbilities, dungeonRewards, dungeonCompletionRewards, genreQuests, extraCreditRewards, sideQuestsDetailed, curseTableDetailed, temporaryBuffsFromRewards, temporaryBuffs, levelRewards, shoppingOptions, wings, restorationProjects, roomThemes };

// atmosphericBuffs and other data are now imported from JSON exports above

// ID-based lookup maps (for stable references)
// Build lookup maps from items that have id fields
export const itemsById = (() => {
    const map = new Map();
    for (const [key, item] of Object.entries(allItems)) {
        if (item.id) {
            map.set(item.id, item);
        }
        // Also allow lookup by key (backward compatibility)
        map.set(key, item);
    }
    return map;
})();

export const itemsByName = (() => {
    const map = new Map();
    for (const [key, item] of Object.entries(allItems)) {
        const name = item.name || key;
        map.set(name, item);
        // Also allow lookup by key (backward compatibility)
        map.set(key, item);
    }
    return map;
})();

/**
 * Get an item by ID or name (backward compatible)
 * @param {string} idOrName - Item ID (kebab-case) or display name
 * @returns {Object|null} Item object or null if not found
 */
export function getItem(idOrName) {
    return itemsById.get(idOrName) || itemsByName.get(idOrName) || allItems[idOrName] || null;
}

// Genre quest lookup maps
export const genreQuestsById = (() => {
    const map = new Map();
    for (const [key, quest] of Object.entries(genreQuests)) {
        if (quest.id) {
            map.set(quest.id, quest);
        }
        map.set(key, quest); // backward compatibility
    }
    return map;
})();

export function getGenreQuest(idOrKey) {
    return genreQuestsById.get(idOrKey) || genreQuests[idOrKey] || null;
}

// Side quest lookup maps
export const sideQuestsById = (() => {
    const map = new Map();
    for (const [key, quest] of Object.entries(sideQuestsDetailed)) {
        if (quest.id) {
            map.set(quest.id, quest);
        }
        map.set(key, quest); // backward compatibility
        if (quest.name) {
            map.set(quest.name, quest);
        }
    }
    return map;
})();

export function getSideQuest(idOrKeyOrName) {
    return sideQuestsById.get(idOrKeyOrName) || sideQuestsDetailed[idOrKeyOrName] || null;
}

// Curse lookup maps
export const cursesById = (() => {
    const map = new Map();
    if (Array.isArray(curseTableDetailed)) {
        curseTableDetailed.forEach((curse) => {
            if (curse.id) {
                map.set(curse.id, curse);
            }
            if (curse.name) {
                map.set(curse.name, curse);
            }
            if (curse.number) {
                map.set(curse.number.toString(), curse);
            }
        });
    }
    return map;
})();

export function getCurse(idOrNameOrNumber) {
    return cursesById.get(idOrNameOrNumber) || null;
}

// Ability lookup maps
export const abilitiesById = (() => {
    const map = new Map();
    for (const [key, ability] of Object.entries(masteryAbilities)) {
        if (ability.id) {
            map.set(ability.id, ability);
        }
        map.set(key, ability); // backward compatibility
        if (ability.name) {
            map.set(ability.name, ability);
        }
    }
    return map;
})();

export function getAbility(idOrName) {
    return abilitiesById.get(idOrName) || masteryAbilities[idOrName] || null;
}

// Atmospheric buff lookup maps
export const atmosphericBuffsById = (() => {
    const map = new Map();
    for (const [key, buff] of Object.entries(atmosphericBuffs)) {
        if (buff.id) {
            map.set(buff.id, buff);
        }
        map.set(key, buff); // backward compatibility
        if (buff.name) {
            map.set(buff.name, buff);
        }
    }
    return map;
})();

export function getAtmosphericBuff(idOrName) {
    return atmosphericBuffsById.get(idOrName) || atmosphericBuffs[idOrName] || null;
}

// Temporary buff lookup maps
export const temporaryBuffsById = (() => {
    const map = new Map();
    for (const [key, buff] of Object.entries(temporaryBuffs)) {
        if (buff.id) {
            map.set(buff.id, buff);
        }
        map.set(key, buff); // backward compatibility
        if (buff.name) {
            map.set(buff.name, buff);
        }
    }
    return map;
})();

export function getTemporaryBuff(idOrName) {
    return temporaryBuffsById.get(idOrName) || temporaryBuffs[idOrName] || null;
}

// Temporary buffs from rewards lookup maps
export const temporaryBuffsFromRewardsById = (() => {
    const map = new Map();
    for (const [key, buff] of Object.entries(temporaryBuffsFromRewards)) {
        if (buff.id) {
            map.set(buff.id, buff);
        }
        map.set(key, buff); // backward compatibility
        if (buff.name) {
            map.set(buff.name, buff);
        }
    }
    return map;
})();

export function getTemporaryBuffFromReward(idOrName) {
    return temporaryBuffsFromRewardsById.get(idOrName) || temporaryBuffsFromRewards[idOrName] || null;
}

// Dungeon room lookup maps
export const dungeonRoomsById = (() => {
    const map = new Map();
    for (const [key, room] of Object.entries(dungeonRooms)) {
        if (room.id) {
            map.set(room.id, room);
        }
        map.set(key, room); // backward compatibility
        if (room.name) {
            map.set(room.name, room);
        }
    }
    return map;
})();

export function getDungeonRoom(idOrKeyOrName) {
    return dungeonRoomsById.get(idOrKeyOrName) || dungeonRooms[idOrKeyOrName] || null;
}

// Restoration project lookup (projects already use IDs as keys)
export function getRestorationProject(id) {
    return restorationProjects[id] || null;
}

// Wing lookup (wings already have id fields)
export const wingsById = (() => {
    const map = new Map();
    for (const [key, wing] of Object.entries(wings)) {
        if (wing.id) {
            map.set(wing.id, wing);
        }
        map.set(key, wing); // backward compatibility
        if (wing.name) {
            map.set(wing.name, wing);
        }
    }
    return map;
})();

export function getWing(idOrKeyOrName) {
    return wingsById.get(idOrKeyOrName) || wings[idOrKeyOrName] || null;
}

/**
 * Get a room theme by ID (for room visualization).
 * @param {string} themeId - Theme id, e.g. 'cozy-modern'
 * @returns {Object|null} Theme object or null if not found
 */
export function getRoomTheme(themeId) {
    return (roomThemes && roomThemes[themeId]) || null;
}

// Derived, backward-compatible shapes from detailed JSON (single source of truth)
export const sideQuests = (() => {
    const result = {};
    for (const key of Object.keys(sideQuestsDetailed)) {
        const sq = sideQuestsDetailed[key];
        // "N: Name: prompt"
        result[key] = `${sq.name}: ${sq.prompt}`;
    }
    return result;
})();

export const curseTable = (() => {
    // Convert detailed array into keyed object with requirement pulled from description semantics
    // Our detailed format does not carry a separate "requirement" field, so we infer from description
    // For backward compatibility, we map requirement to the sentence after the first period if present,
    // and normalize it by removing a leading "You must " and trailing punctuation.
    const result = {};
    const normalizeRequirement = (text) => {
        let req = (text || '').trim();
        const lower = req.toLowerCase();
        if (lower.startsWith('you must ')) {
            req = req.substring(9);
        }
        if (req.endsWith('.')) {
            req = req.substring(0, req.length - 1);
        }
        return req.trim();
    };
    for (const entry of curseTableDetailed) {
        const { name, description } = entry;
        let requirementText = description;
        const periodIndex = description.indexOf('. ');
        if (periodIndex !== -1) {
            requirementText = description.substring(periodIndex + 2);
        }
        const requirement = normalizeRequirement(requirementText);
        result[name] = {
            name,
            requirement,
            description
        };
    }
    return result;
})();
